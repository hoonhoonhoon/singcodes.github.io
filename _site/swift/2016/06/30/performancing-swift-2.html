<!DOCTYPE html>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title></title>
	<!-- Begin Jekyll SEO tag v2.1.0 -->
<title>Performancing swift 2</title>
<meta property="og:title" content="Performancing swift 2" />
<meta name="description" content="Understanding swift performance의 나머지부분에 대한 이해를 하기에 앞서 Objective-C와 Swift가 실제로 어떻게 메소드를 호출하는지 잠깐(이 될지..) 짚어보고 넘어가보겠습니다." />
<meta property="og:description" content="Understanding swift performance의 나머지부분에 대한 이해를 하기에 앞서 Objective-C와 Swift가 실제로 어떻게 메소드를 호출하는지 잠깐(이 될지..) 짚어보고 넘어가보겠습니다." />
<link rel="canonical" href="http://localhost:4000/swift/2016/06/30/performancing-swift-2.html" />
<meta property="og:url" content="http://localhost:4000/swift/2016/06/30/performancing-swift-2.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-06-30T04:08:54+09:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@singcodes" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "BlogPosting",
"headline": "Performancing swift 2",
"datePublished": "2016-06-30T04:08:54+09:00",
"description": "Understanding swift performance의 나머지부분에 대한 이해를 하기에 앞서 Objective-C와 Swift가 실제로 어떻게 메소드를 호출하는지 잠깐(이 될지..) 짚어보고 넘어가보겠습니다.",
"url": "http://localhost:4000/swift/2016/06/30/performancing-swift-2.html"}</script>
<!-- End Jekyll SEO tag -->

	<link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" />
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<!--[if lte IE 8]><script src="http://localhost:4000/assets/js/ie/html5shiv.js"></script><![endif]-->
	<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css" />
	<!--[if lte IE 9]><link rel="stylesheet" href="http://localhost:4000/assets/css/ie9.css" /><![endif]-->
	<!--[if lte IE 8]><link rel="stylesheet" href="http://localhost:4000/assets/css/ie8.css" /><![endif]-->
</head>

<body>

    <!-- Wrapper -->
<div id="wrapper">

<!-- Header -->
<header id="header">
	<a href="http://localhost:4000" class="logo"><strong>Sing Swift</strong> <span></span></a>
	<nav>
		<a href="#menu">Menu</a>
	</nav>
</header>

<!-- Menu -->
<nav id="menu">
	<ul class="links">
        
		    
		
		    
		
		    
		        <li><a href="/">Home</a></li>
	    	
		
		    
		
		    
		
		    
		
		
		    
		        <li><a href="/elements.html">Elements</a></li>
		    
		
		    
		        <li><a href="/generic.html">Generic</a></li>
		    
		
		    
		
		    
		        <li><a href="/landing.html">Landing</a></li>
		    
		
		    
		        <li><a href="/feed.xml"></a></li>
		    
		
		    
		        <li><a href="/feed.xslt.xml"></a></li>
		    
		
	</ul>
	<ul class="actions vertical">
		<li><a href="#" class="button special fit">Get Started</a></li>
		<li><a href="#" class="button fit">Log In</a></li>
	</ul>
</nav> 
    
    
<!-- Main -->
<div id="main" class="alt">

<!-- One -->
<section id="one">
	<div class="inner">
		<header class="major">
			<h1>Performancing swift  2</h1>
		</header>
		
		<p><p><a href="https://developer.apple.com/videos/play/wwdc2016/416/06/27/performancing-swift-1/">Understanding swift performance</a>의 나머지부분에 대한 이해를 하기에 앞서 Objective-C와 Swift가 실제로 어떻게 메소드를 호출하는지 잠깐(이 될지..) 짚어보고 넘어가보겠습니다.</p>

<p>테스트를 위해 먼저 프로젝트를 하나 생성합니다.</p>

<p><img src="https://singcodes.files.wordpress.com/2016/06/e18489e185b3e1848fe185b3e18485e185b5e186abe18489e185a3e186ba-2016-06-30-e1848be185a9e1848ce185a5e186ab-2-01-01.png" alt="스크린샷 2016-06-30 오전 2.01.01" /></p>

<p>Debugging이라는 이름으로  macOS용 Command Line Tool프로젝트를 생성했습니다.</p>

<p>그리고 테스트를 위한 간단한 클래스를 몇개 작성해보겠습니다.</p>

<h3 id="test1">Test1</h3>

<ul>
  <li>Objective C 객체입니다.</li>
</ul>

<p>[code language=”objc”]</p>

<p>@interface Test1 : NSObject</p>

<ul>
  <li>(void)test;</li>
</ul>

<p>@end</p>

<p>@implementation Test1</p>

<ul>
  <li>(void)test {
NSLog(@”Test1(NSObject)-&gt;test”);
}</li>
</ul>

<p>@end</p>

<p>[/code]</p>

<h3 id="test2">Test2</h3>

<ul>
  <li>
    <p>swift class 입니다.</p>
  </li>
  <li>
    <p>test(), test2()는 보통의 dynamic 함수이며, finalTest()는 final 지시자를 통해 상속이 불가능한 static 함수로 선언했습니다.</p>
  </li>
</ul>

<p>[code language=”objc”]
class Test2 {
func test() {
print(“Test2(class)-&gt;test()”)
}
func test2() {
print(“Test2(class)-&gt;test2()”)
}
final func finalTest() {
print(“Test2(class)-&gt;finalTest()”)
}
}
[/code]</p>

<h3 id="testobj">TestObj</h3>

<ul>
  <li>swift class이지만, Objective-C에서도 사용이 가능하도록 @objc지시자와 함께 NSObject를 상속한 클래스입니다.</li>
</ul>

<p>[code language=”objc”]</p>

<p>@objc class TestObj: NSObject {</p>

<p>func test() {
print(“TestObj(class)-&gt;test()”)
}</p>

<p>}
[/code]</p>

<h3 id="test4--test3">Test4 : Test3</h3>

<ul>
  <li>
    <p>Test3는 protocol이며 extension을 통해 test함수를 추가했습니다.</p>
  </li>
  <li>
    <p>Test4는 Test3프로토콜을 상속한 struct이고 Test3의 test함수와 구별하기 위해 testStruct함수를 추가했습니다.</p>
  </li>
</ul>

<p>[code language=”objc”]</p>

<p>protocol Test3 {
func test() -&gt; Void
}</p>

<p>extension Test3 {
func test() -&gt; Void {
print(“Test3(protocol)-&gt;test()”)
}
}</p>

<p>struct Test4 : Test3 {
func testStruct() -&gt; Void {
print(“Test4(struct)-&gt;testStruct”)
}
}</p>

<p>[/code]</p>

<h3 id="main">main</h3>

<ul>
  <li>main함수는 앞에서 작성한 객체들을 실행합니다.</li>
</ul>

<p>[code language=”objc”]</p>

<p>import Foundation</p>

<p>let ti = Test1()
ti.test()
let t2 = Test2()
t2.test()
t2.test2()
t2.finalTest()
let to = TestObj()
to.test()
let t4 = Test4()
t4.test()
t4.testStruct()</p>

<p>exit(0)</p>

<p>[/code]</p>

<p><strong>자 그럼 한번 실행을 시켜보겠습니다</strong></p>

<p>[code language=”text”]</p>

<p>2016-06-30 02:29:46.600991 Debugging[837:215769] Test1(NSObject)-&gt;test
Test2(class)-&gt;test()
Test2(class)-&gt;test2()
Test2(class)-&gt;finalTest()
TestObj(class)-&gt;test()
Test3(protocol)-&gt;test()
Test4(struct)-&gt;testStruct
[/code]</p>

<p>차란~ 멋지게 실행이 됐군요. 이제 된걸까요?</p>

<p>초반에 말했지만, 메소드와 함수의 실행에 대해서 저희는 이것보다 좀더 깊이 들어가야합니다.</p>

<p>main 함수의 후반에 exit(0)라인이 있습니다. 여기에 브레이크 포인트를 걸어봅시다.</p>

<p><img src="https://singcodes.files.wordpress.com/2016/06/e18489e185b3e1848fe185b3e18485e185b5e186abe18489e185a3e186ba-2016-06-30-e1848be185a9e1848ce185a5e186ab-2-33-21.png" alt="스크린샷 2016-06-30 오전 2.33.21" /></p>

<p>그리고 다시 실행하면 실행이 브레이크포인트에서 멈추면서 화면 우측 하단에 이런 화면이 등장합니다.</p>

<p><img src="https://singcodes.files.wordpress.com/2016/06/e18489e185b3e1848fe185b3e18485e185b5e186abe18489e185a3e186ba-2016-06-30-e1848be185a9e1848ce185a5e186ab-2-34-41.png" alt="스크린샷 2016-06-30 오전 2.34.41" /></p>

<p>이 화면은 디버그 콘솔이 활성화 되었다는 표시입니다. 여러분은 이 콘솔에서 정말 많은 것을 할 수 있습니다만, 아쉽게도 지금 필요한 건 단 하나의 명령어입니다. 다음과 같이 입력하고 엔터를 눌러보세요.</p>

<p>[code language=”C”]</p>

<p>(lldb) di -m</p>

<p>혹은</p>

<p>(lldb) disassemble –mixed</p>

<p>[/code]</p>

<p>그러면 다음과 같은, 여러분이 응당 없어야 했지만, 천재지변과도 같은 어쩔수 없는 어떤 신의 섭리로 인해 에러를 내서 앱이 크래쉬를 발생할 수 밖에 없던 그때의 기억을 떠올리게 하는 코드들이 좌라락 펼쳐집니다.</p>

<p><strong>저의 디버그 콘솔 화면을 그대로 옮겨봅니다.</strong></p>

<p>[code language=”C”]</p>

<p>2016-06-30 02:55:45.526713 Debugging[989:315089] Test1(NSObject)-&gt;test
Test2(class)-&gt;test()
Test2(class)-&gt;test2()
Test2(class)-&gt;finalTest()
TestObj(class)-&gt;test()
Test3(protocol)-&gt;test()
Test4(struct)-&gt;testStruct
(lldb) di -f -m
Debugging<code class="highlighter-rouge">main at main.swift
1 //
2 // main.swift
3 // Debugging
Debugging</code>main:
0x10031b150 &lt;+0&gt;: pushq %rbp
0x10031b151 &lt;+1&gt;: movq %rsp, %rbp
0x10031b154 &lt;+4&gt;: subq $0x30, %rsp
0x10031b158 &lt;+8&gt;: leaq 0x9fab1(%rip), %rax ; globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_token4
0x10031b15f &lt;+15&gt;: leaq 0x9faa6(%rip), %rcx ; static Swift.Process._argc : Swift.Int32
Debugging<code class="highlighter-rouge">main + 22 at main.swift
1 //
2 // main.swift
3 // Debugging
0x10031b166 &lt;+22&gt;: movl %edi, (%rcx)
0x10031b168 &lt;+24&gt;: cmpq $-0x1, (%rax)
0x10031b16c &lt;+28&gt;: movq %rsi, -0x8(%rbp)
0x10031b170 &lt;+32&gt;: je 0x10031b188 ; &lt;+56&gt; at main.swift
0x10031b172 &lt;+34&gt;: leaq 0x9fa97(%rip), %rdi ; globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_token4
0x10031b179 &lt;+41&gt;: leaq -0xdbe50(%rip), %rax ; globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func4
0x10031b180 &lt;+48&gt;: movq %rax, %rsi
0x10031b183 &lt;+51&gt;: callq 0x10030e8f0 ; swift_once
0x10031b188 &lt;+56&gt;: leaq 0x9fa89(%rip), %rax ; static Swift.Process._unsafeArgv : Swift.Optional&lt;Swift.UnsafeMutablePointer&lt;Swift.Optional&lt;Swift.UnsafeMutablePointer&lt;Swift.Int8&gt;&gt;
0x10031b18f &lt;+63&gt;: movq -0x8(%rbp), %rcx
0x10031b193 &lt;+67&gt;: movq %rcx, (%rax)
Debugging</code>main + 70 at main.swift:12
11
12 var ti: Test1 = Test1()
13 ti.test()
0x10031b196 &lt;+70&gt;: callq 0x10031b320 ; type metadata accessor for __ObjC.Test1 at main.swift
Debugging<code class="highlighter-rouge">main + 75 at main.swift:12
11
12 var ti: Test1 = Test1()
13 ti.test()
0x10031b19b &lt;+75&gt;: movq %rax, %rdi
0x10031b19e &lt;+78&gt;: callq 0x10031b2d0 ; __ObjC.Test1.__allocating_init () -&gt; __ObjC.Test1 at main.swift
0x10031b1a3 &lt;+83&gt;: movq %rax, 0x9fb4e(%rip) ; Debugging.ti : __ObjC.Test1
Debugging</code>main + 90 at main.swift:13
12 var ti: Test1 = Test1()
13 ti.test()
14 var t2 = Test2()
0x10031b1aa &lt;+90&gt;: movq 0x9fb47(%rip), %rax ; Debugging.ti : __ObjC.Test1
0x10031b1b1 &lt;+97&gt;: movq %rax, %rdi
0x10031b1b4 &lt;+100&gt;: movq %rax, -0x10(%rbp)
0x10031b1b8 &lt;+104&gt;: callq 0x10031b50a ; symbol stub for: objc_retain
Debugging<code class="highlighter-rouge">main + 109 at main.swift:13
12 var ti: Test1 = Test1()
13 ti.test()
14 var t2 = Test2()
0x10031b1bd &lt;+109&gt;: movq 0x7c1b4(%rip), %rsi ; &amp;quot;test&amp;quot;
0x10031b1c4 &lt;+116&gt;: movq -0x10(%rbp), %rcx
0x10031b1c8 &lt;+120&gt;: movq %rcx, %rdi
0x10031b1cb &lt;+123&gt;: movq %rax, -0x18(%rbp)
0x10031b1cf &lt;+127&gt;: callq 0x10031b4ec ; symbol stub for: objc_msgSend
0x10031b1d4 &lt;+132&gt;: movq -0x10(%rbp), %rdi
0x10031b1d8 &lt;+136&gt;: callq 0x10031b504 ; symbol stub for: objc_release
Debugging</code>main + 141 at main.swift:14
13 ti.test()
14 var t2 = Test2()
15 t2.test()
0x10031b1dd &lt;+141&gt;: callq 0x10031aa40 ; type metadata accessor for Debugging.Test2 at Test2.swift
Debugging<code class="highlighter-rouge">main + 146 at main.swift:14
13 ti.test()
14 var t2 = Test2()
15 t2.test()
0x10031b1e2 &lt;+146&gt;: movq %rax, %rdi
0x10031b1e5 &lt;+149&gt;: callq 0x10031aa00 ; Debugging.Test2.__allocating_init () -&gt; Debugging.Test2 at Test2.swift:11
0x10031b1ea &lt;+154&gt;: movq %rax, 0x9fb0f(%rip) ; Debugging.t2 : Debugging.Test2
Debugging</code>main + 161 at main.swift:15
14 var t2 = Test2()
15 t2.test()
16 t2.test2()
0x10031b1f1 &lt;+161&gt;: movq 0x9fb08(%rip), %rax ; Debugging.t2 : Debugging.Test2
0x10031b1f8 &lt;+168&gt;: movq %rax, %rcx
0x10031b1fb &lt;+171&gt;: movq %rcx, %rdi
0x10031b1fe &lt;+174&gt;: movq %rax, -0x20(%rbp)
0x10031b202 &lt;+178&gt;: callq 0x10031b370 ; rt_swift_retain
Debugging<code class="highlighter-rouge">main + 183 at main.swift:15
14 var t2 = Test2()
15 t2.test()
16 t2.test2()
0x10031b207 &lt;+183&gt;: movq -0x20(%rbp), %rax
0x10031b20b &lt;+187&gt;: movq (%rax), %rcx
Debugging</code>main + 190 at main.swift:15
14 var t2 = Test2()
15 t2.test()
16 t2.test2()
0x10031b20e &lt;+190&gt;: movq %rax, %rdi
0x10031b211 &lt;+193&gt;: callq *0x50(%rcx)
0x10031b214 &lt;+196&gt;: movq -0x20(%rbp), %rdi
0x10031b218 &lt;+200&gt;: callq 0x10031b380 ; rt_swift_release
Debugging<code class="highlighter-rouge">main + 205 at main.swift:16
15 t2.test()
16 t2.test2()
17 t2.finalTest()
0x10031b21d &lt;+205&gt;: movq 0x9fadc(%rip), %rax ; Debugging.t2 : Debugging.Test2
0x10031b224 &lt;+212&gt;: movq %rax, %rcx
0x10031b227 &lt;+215&gt;: movq %rcx, %rdi
0x10031b22a &lt;+218&gt;: movq %rax, -0x28(%rbp)
0x10031b22e &lt;+222&gt;: callq 0x10031b370 ; rt_swift_retain
Debugging</code>main + 227 at main.swift:16
15 t2.test()
16 t2.test2()
17 t2.finalTest()
0x10031b233 &lt;+227&gt;: movq -0x28(%rbp), %rax
0x10031b237 &lt;+231&gt;: movq (%rax), %rcx
Debugging<code class="highlighter-rouge">main + 234 at main.swift:16
15 t2.test()
16 t2.test2()
17 t2.finalTest()
0x10031b23a &lt;+234&gt;: movq %rax, %rdi
0x10031b23d &lt;+237&gt;: callq *0x58(%rcx)
0x10031b240 &lt;+240&gt;: movq -0x28(%rbp), %rdi
0x10031b244 &lt;+244&gt;: callq 0x10031b380 ; rt_swift_release
Debugging</code>main + 249 at main.swift:17
16 t2.test2()
17 t2.finalTest()
18 let to = TestObj()
0x10031b249 &lt;+249&gt;: movq 0x9fab0(%rip), %rax ; Debugging.t2 : Debugging.Test2
0x10031b250 &lt;+256&gt;: movq %rax, %rcx
0x10031b253 &lt;+259&gt;: movq %rcx, %rdi
0x10031b256 &lt;+262&gt;: movq %rax, -0x30(%rbp)
0x10031b25a &lt;+266&gt;: callq 0x10031b370 ; rt_swift_retain
Debugging<code class="highlighter-rouge">main + 271 at main.swift:17
16 t2.test2()
17 t2.finalTest()
18 let to = TestObj()
0x10031b25f &lt;+271&gt;: movq -0x30(%rbp), %rdi
0x10031b263 &lt;+275&gt;: callq 0x10031a900 ; Debugging.Test2.finalTest () -&gt; () at Test2.swift:19
0x10031b268 &lt;+280&gt;: movq -0x30(%rbp), %rdi
0x10031b26c &lt;+284&gt;: callq 0x10031b380 ; rt_swift_release
Debugging</code>main + 289 at main.swift:18
17 t2.finalTest()
18 let to = TestObj()
19 to.test()
0x10031b271 &lt;+289&gt;: callq 0x10031abc0 ; type metadata accessor for Debugging.TestObj at Test2.swift
Debugging<code class="highlighter-rouge">main + 294 at main.swift:18
17 t2.finalTest()
18 let to = TestObj()
19 to.test()
0x10031b276 &lt;+294&gt;: movq %rax, %rdi
0x10031b279 &lt;+297&gt;: callq 0x10031ac40 ; Debugging.TestObj.__allocating_init () -&gt; Debugging.TestObj at Test2.swift:25
0x10031b27e &lt;+302&gt;: leaq 0x9fa43(%rip), %rcx ; swift_isaMask
0x10031b285 &lt;+309&gt;: movq %rax, 0x9fa7c(%rip) ; Debugging.to : Debugging.TestObj
Debugging</code>main + 316 at main.swift:19
18 let to = TestObj()
19 to.test()
20 let t4 = Test4()
0x10031b28c &lt;+316&gt;: movq 0x9fa75(%rip), %rax ; Debugging.to : Debugging.TestObj
Debugging<code class="highlighter-rouge">main + 323 at main.swift:19
18 let to = TestObj()
19 to.test()
20 let t4 = Test4()
0x10031b293 &lt;+323&gt;: movq (%rax), %rsi
0x10031b296 &lt;+326&gt;: andq (%rcx), %rsi
Debugging</code>main + 329 at main.swift:19
18 let to = TestObj()
19 to.test()
20 let t4 = Test4()
0x10031b299 &lt;+329&gt;: movq %rax, %rdi
0x10031b29c &lt;+332&gt;: callq *0x50(%rsi)
Debugging<code class="highlighter-rouge">main + 335 at main.swift:20
19 to.test()
20 let t4 = Test4()
21 t4.test()
0x10031b29f &lt;+335&gt;: callq 0x10031ae60 ; Debugging.Test4.init () -&gt; Debugging.Test4 at Test2.swift:42
0x10031b2a4 &lt;+340&gt;: leaq 0x74acd(%rip), %rdi ; type metadata for Debugging.Test4
0x10031b2ab &lt;+347&gt;: leaq 0x749c6(%rip), %rsi ; protocol witness table for Debugging.Test4 : Debugging.Test3 in Debugging
Debugging</code>main + 354 at main.swift:21
20 let t4 = Test4()
21 t4.test()
22 t4.testStruct()
0x10031b2b2 &lt;+354&gt;: callq 0x10031ad00 ; (extension in Debugging):Debugging.Test3.test () -&gt; () at Test2.swift:37
Debugging<code class="highlighter-rouge">main + 359 at main.swift:22
21 t4.test()
22 t4.testStruct()
23 exit(0)
0x10031b2b7 &lt;+359&gt;: callq 0x10031adc0 ; Debugging.Test4.testStruct () -&gt; () at Test2.swift:43
0x10031b2bc &lt;+364&gt;: xorl %edi, %edi
Debugging</code>main + 366 at main.swift:23
22 t4.testStruct()
-&gt; 23 exit(0)
-&gt; 0x10031b2be &lt;+366&gt;: callq 0x10031b7ec ; symbol stub for: exit
0x10031b2c3 &lt;+371&gt;: nopw %cs:(%rax,%rax)
(lldb)</p>

<p>[/code]</p>

<p>뭔가 개발자다운 짓을 하고 있다는 것에 뿌듯합니다. 하지만 위의 정보에는 너무 불필요한 것들이 많습니다. 한단계 한단계 잘 살펴봐야겠네요.</p>

<p>di -m 혹은 disassemble –mixed 명령은 현재 frame(여러개의 명령어로 구성된 실행단위입니다. 대개 함수나 메소드 단위로 범위가 정해집니다,.위의 경우 보이지는 않지만,  main의 전역 함수에 속해있습니다.)</p>

<p>Test1 객체에 대한 부분을 찾아봅시다.</p>

<p>[code language=”C”]</p>

<p>12 var ti: Test1 = Test1()
13 ti.test()
callq 0x10031b320 ; type metadata accessor for __ObjC.Test1 at main.swift
movq %rax, %rdi
callq 0x10031b2d0 ; __ObjC.Test1.__allocating_init () -&amp;amp;amp;gt; __ObjC.Test1 at main.swift
movq %rax, 0x9fb4e(%rip) ; Debugging.ti : __ObjC.Test1
movq 0x9fb47(%rip), %rax ; Debugging.ti : __ObjC.Test1
movq %rax, %rdi
movq %rax, -0x10(%rbp)
callq 0x10031b50a ; symbol stub for: objc_retain
여기까지는 객체의 생성에 대한 부분입니다.
14 var t2 = Test2()
movq 0x7c1b4(%rip), %rsi ; &amp;quot;test&amp;quot;
movq -0x10(%rbp), %rcx
movq %rcx, %rdi
movq %rax, -0x18(%rbp)
callq 0x10031b4ec ; symbol stub for: objc_msgSend
여기까지는 test메소드의 호출에 대한 부분입니다.
movq -0x10(%rbp), %rdi
callq 0x10031b504 ; symbol stub for: objc_release
객체의 수명이 다하고, 메모리의 세상을 떠나 2진수 천국으로 향합니다. 다음에는 4진수로 태어나기를..
[/code]</p>

<p>뭐가 참 길죠? 클래스가 이렇게 무섭습니다 여러분.</p>

<p>과정은 다음과 같습니다.</p>

<ol>
  <li>
    <p>객체에 접근 하기 위해 객체 타입에 대한 metadata 접근자를 호출</p>
  </li>
  <li>
    <p>객체정보를 알아낸 후, alloc과 init을 실행합니다.</p>
  </li>
  <li>
    <p>객체에 대한 소유권을 얻습니다. -&gt; objc_retain</p>
  </li>
  <li>
    <p> objc_msgSend 함수를 통해 test메소드를 찾아 실행합니다.</p>
  </li>
  <li>
    <p>모든 작업이 끝나고 객체에게 사망선고를 내립니다.</p>
  </li>
</ol>

<p>instruments나 기타 디버깅 작업을 하시다보면 objc_msgSend호출이 실행 루틴에서 거의 반을 차지한다는 것을 알게 되실겁니다. 메소드를 호출하기 위해 반드시 실행되는 함수이기 때문이죠.  다행이 이에 대해 제가 길게 설명할 필요는 없을거 같습니다. 여기 <a href="http://b4you.net/blog/tag/objc_msgSend()">옛 선현</a>의 글을 궁금하면 파보시기 바랍니다.</p>

<p>이제 대충 어셈블리 소스를 어떻게 보면 될지 파악이 끝나셨죠? 저는 여러분을 믿습니다. 네 이제 어셈블리 코드 정리는 안해도 될 거같군요.</p>

<p>Test2객체 순서는 다음과 같습니다.</p>

<ol>
  <li>
    <p>객체에 접근 하기 위해 객체 타입에 대한 metadata 접근자를 호출</p>
  </li>
  <li>
    <p>객체정보를 알아낸 후, alloc과 init을 실행합니다.</p>
  </li>
  <li>
    <p>객체에 대한 소유권을 얻습니다. -&gt; objc_retain</p>
  </li>
  <li>
    <p>함수를 실행하지만,  Objective C와 다르게 objc_msgSend를 호출하지 않습니다.</p>
  </li>
  <li>
    <p>dynamic함수인 test()와 test2()의 경우 rcx레지스터를 통해 함수를 호출하는 것으로 보입니다.</p>
  </li>
  <li>
    <p>그와는 다르게  static함수인 finalTest()의 경우 메모리 번지를 바로 참조하여 함수를 호출합니다.</p>
  </li>
  <li>
    <p>모든 작업이 끝나고 객체에게 사망선고를 내립니다.</p>
  </li>
</ol>

<p><em>클래스인 경우 Objective C던 swift던 메소드, 함수를 호출할 때마다 객체에 대한 소유와 해지가 계속 발생합니다. 퍼포먼스 관점에서 중요한 부분이라고 생각합니다.</em></p>

<p>TestObjec의 객체는 생성을 제외하고는 callq의 호출을 끝으로 자세한 내용을 알 수가 없이 금방 지나갑니다. 그리고, Objective C클래스인 Test1와 다르게 명시적인 reference counting을 볼 수가 없습니다. 디버그 명령어의 문제일까요? 아니면 Objective C객체와 @objc class의 구조 차이일까요? 공부를 더 해야할 부분입니다.</p>

<p>Test4구조체는 다음과 같습니다.</p>

<p>[code language=”C”]</p>
<pre>Debugging`main + 335 at main.swift:20
19 to.test()
20 let t4 = Test4()
21 t4.test()
22 t4.testStruct()
23 exit(0)
callq 0x10031ae60 ; Debugging.Test4.init () -&gt; Debugging.Test4 at Test2.swift:42
Test4구조체를 초기화합니다

leaq 0x74acd(%rip), %rdi ; type metadata for Debugging.Test4
leaq 0x749c6(%rip), %rsi ; protocol witness table for Debugging.Test4 : Debugging.Test3 in Debugging
callq 0x10031ad00 ; (extension in Debugging):Debugging.Test3.test () -&gt; () at Test2.swift:37
Text4 구조체를 통해 호출했지만, 사실 Test3프로토콜의 extension함수인 test()를 호출합니다.
callq 0x10031adc0 ; Debugging.Test4.testStruct () -&gt; () at Test2.swift:43
xorl %edi, %edi
Test4 구조체의 testStruct()함수를 호출합니다.
callq 0x10031b7ec ; symbol stub for: exit
nopw %cs:(%rax,%rax)
main 함수를 종료합니다.</pre>
<p>[/code]</p>

<ol>
  <li>
    <p>객체 타입에 대한 metadata를 메모리로 불러들입니다.</p>
  </li>
  <li>
    <p>protocol witness table을 메모리로 불러들입니다.</p>
  </li>
  <li>
    <p>각 함수의 메모리에 바로 접근하여 호출합니다.</p>
  </li>
  <li>
    <p>끝</p>
  </li>
</ol>

<p>클래스와 비교하여 struct의 생성과 함수 호출은 매우 적은 수의 명령어셋으로 이루어져 있음을 확인 할 수 있습니다.</p>

<p>더욱 상세하게 파고 들어가려면 <a href="https://github.com/apple/swift/blob/master/docs/ABI.rst#the-swift-abi">ABI</a>와 <a href="http://llvm.org/devmtg/2015-10/slides/GroffLattner-SILHighLevelIR.pdf">SIL</a>에 대해 살펴보시면 좋을겁니다.</p>

<p>이제 Understanding swift performance의 나머지 부분에 대해 알 준비가 되셨다고 생각합니다.</p>

<p>부족한 글 읽어주셔서 고맙습니다.</p>

<p>곧 다음글도 올리겠습니다.</p>

</p>
	</div>
</section>

</div>

    <!-- Contact -->
<section id="contact">
	<div class="inner">
		<section>
			<form action="https://formspree.io/eyerama@gmail.comm" method="POST">
				<div class="field half first">
					<label for="name">Name</label>
					<input type="text" name="name" id="name" />
				</div>
				<div class="field half">
					<label for="email">Email</label>
					<input type="text" name="_replyto" id="email" />
				</div>
				<div class="field">
					<label for="message">Message</label>
					<textarea name="message" id="message" rows="6"></textarea>
				</div>
				<ul class="actions">
					<li><input type="submit" value="Send Message" class="special" /></li>
					<li><input type="reset" value="Clear" /></li>
				</ul>
			</form>
		</section>
		<section class="split">
			<section>
				<div class="contact-method">
					<span class="icon alt fa-envelope"></span>
					<h3>Email</h3>
					<a href="#">eyerama@gmail.comm</a>
				</div>
			</section>
			<section>
				<div class="contact-method">
					<span class="icon alt fa-phone"></span>
					<h3>Phone</h3>
					<span></span>
				</div>
			</section>
			<section>
				<div class="contact-method">
					<span class="icon alt fa-home"></span>
					<h3>Address</h3>
					<span><br />
					,  <br />
					</span>
				</div>
			</section>
		</section>
	</div>
</section>

<!-- Footer -->
	<footer id="footer">
		<div class="inner">
			<ul class="icons">
				
				
				
				
				
				
				
				
				
				
			</ul>
			<ul class="copyright">
				<li>&copy; Sing Swift </li>
				<li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li>
				<li>Jekyll integration: <a href="http://andrewbanchi.ch" target="_blank">Andrew Banchich</a></li>
				
			</ul>
		</div>
	</footer>

</div>

<!-- Scripts -->
	<script src="http://localhost:4000/assets/js/jquery.min.js"></script>
	<script src="http://localhost:4000/assets/js/jquery.scrolly.min.js"></script>
	<script src="http://localhost:4000/assets/js/jquery.scrollex.min.js"></script>
	<script src="http://localhost:4000/assets/js/skel.min.js"></script>
	<script src="http://localhost:4000/assets/js/util.js"></script>
	<!--[if lte IE 8]><script src="http://localhost:4000/assets/js/ie/respond.min.js"></script><![endif]-->
	<script src="http://localhost:4000/assets/js/main.js"></script>


</body>

</html>